
# 正则表达式 支持的所有元字符:
#       . ^ $ * + ? {} [] \ | ()
# . 匹配任何一个字符(而不是标点符号)
# \ 转义符,eg.想精确匹配"." 可以"\."
#       \d 匹配任何一个十进制数字,相当于[0-9]
#       \D 匹配任何一个非十进制数字,相当于[^0-9]
#       \s 匹配任何一个空白字符,相当于[\t\n\r\f\v]
#       \S 匹配任何一个非空白字符,相当于[^\t\n\r\f\v]
#       \w 匹配任何一个字母数字字符,相当于[a-zA-Z0-9_]
#       \w 匹配任何一个非字母数字字符,相当于[^a-zA-Z0-9_]
# [] 匹配任何一类字符 
#       eg.[abcd]将匹配 'a' 'b' 'c' 'd' 中的任意一个字符,
#       可加"-"表示范围, eg.[a-d] 同 [abcd]
# * 重复匹配前面一个字符 "0-无穷多" 次, eg 1*2 可以匹配 2 12 112 1112 11112 111112 ...
# + 重复匹配前面一个字符 "1-无穷多" 次, eg 1+2 可以匹配   12 112 1112 11112 111112 ...
# ? 重复匹配前面一个字符 "0-1" 次, eg 1?2 可以匹配      2 12
#       还有一个作用:  ?" 表示接下来匹配到 " 之后就不再继续匹配,这对于 "abc"."def" 这种只想拿到"abc" 的case很有用
#       这对于左右括号,左右引号之类的模式匹配很有用
# {} 重复匹配前面一个字符 指定范围 次, 算上前一个字符一共
#       eg.1{3}2 可以匹配 1112, 而 1{3,5}可以匹配1112 11112 111112
#       eg.\d{8} 可以匹配八个数字  -------------------------??? 八个不是九个
# ^ 一行的起始,相当于是\n之后的那个字符, 放在[]中相当于取反[^x]
# $ 一行的末尾,相当于是\n, eg.匹配一行就是 "^.*$"  不过python可以直接用split("\n")
# | 相当于或,任意一个正则表达式匹配上就算匹配上
# () 分组,告诉 {} 需要重复的target, 匹配之后的字串也会按照 组 的方式
#       eg.匹配一个ip地址 (eg. 192.168.0.1):
#               \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
#               (\d{1,3}\.){3}\d{1,3}  #当获取了这个字串的时候,('192','168','0','1')会被组织成一个元组



#一个例子:提取存档的html文件中所有的网址
# http:// 开头,或者 https:// 开头,然后是任意一个字符,(重复任意次),网址一般被""包起来

import re

p = re.compile('"https?://.*?"', re.IGNORECASE) # ?" 表示找到离前面一个"最近的"之后就不再继续匹配
#p = re.compile('"http://.*?"|"https://.*?"', re.I) # re.IGNORECASE 和 re.I 都表示忽略大小写

with open("/home/fang/桌面/demo.html") as fr:
    doc = fr.read()
    print(type(doc))
    # findall() 找到所有匹配的字串,作为一个list返回
    # search()  扫描字符串,找到RE匹配的位置(只返回第一个的位置)
    # match() 会返回一个match对象
    for i in p.findall(doc):
        print (type(i), i)



