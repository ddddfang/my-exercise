
	NNCL_MEMORY_T debug;		//debug
	int size=0;	//debug
	void *p=NULL;//debug

	size = NnclRefGetTensorSize(pyDesc)*sizeof(pyDesc->dataType);	//debug
	NnMemAlloc(&debug, NNCL_MEM_TYPE_HOST, size);	//debug
	nnclMemCpy(debug, 0, pyMem, 0, size);	//debug
	p = NnMemGetBase(debug, NNCL_MEM_TYPE_HOST);	//debug
	p = NULL;


        //C[offc + y*N + x] = alpha_half*value + beta_half*C[offc + y*N + x];
        tmpc = vload_half(offc + y*N + x, C);
        vstore_half(ALPHA*value + BETA*tmpc, offc + y*N + x, C);




/***********************************************************************************
*              Copyright 2016 - 2020 Shanghai ZhaoXin Semiconductor Co., Ltd.
* 
* FileName    :   zxnn_cl_common.c
* Description :   
* 
* History     :   
* Version         Date                        Author            Description
* 1.0             2019-04-29 13:46:56                           Create the file.
*                                                               Last modified time.
***********************************************************************************/

#include "zxnn_cl_common.h"
#include <cstring>
#include <iostream>
#include <fstream>
#include <sstream>

//process "-ZX_HEADER" option:
//	Input: const char build_options[] = "-DLENGTH=12 -ZX_HEADER cl/abc.clT cl/def.clT -I include/";
//	Output: the content of "cl/abc.clT + cl/def.clT" files
//	NOTICE: it will remove  "-ZX_HEADER cl/abc.clT cl/def.clT" from s_ori !
std::string processZxHeader(std::string &s_ori)
{
	std::string tag_header = "-ZX_HEADER ";
	std::string tag_tail = ".clT";

	std::size_t pos_header = s_ori.find(tag_header);	//find position of "-ZX_HEADER "
	std::size_t pos_tail=0;
	std::string file_content;

	if(pos_header != s_ori.npos)
	{
		std::size_t pos_begin = pos_header + tag_header.length(); //position begin of file name
		std::size_t pos_end = 0;                                  //position end   of file name
		while((pos_tail=s_ori.find(tag_tail,pos_tail)) != s_ori.npos)	//find position of ".clT " from pos_tail position
		{
			pos_end = pos_tail + tag_tail.length();

			//get header file name string
			std::string target = s_ori.substr(pos_begin, pos_end-pos_begin);//-1: erase space of "clT".
			std::cout<<"target=\""<<target<<"\""<<std::endl;

			std::ifstream header(target.c_str());//header.open(target.data());
			if(header.is_open())
			{
				std::stringstream buffer;
				buffer << header.rdbuf();  //read file content in stringstream object
				file_content.append(buffer.str());
			}
			else 
			{
				std::cout<<"open "<<target<<" fail."<<std::endl;
				return "";
			}

			pos_begin = pos_end;	//position begin of next "cl/xxx.clT" (if have, SHOULD follow priv cl/xxx.clT)
			pos_tail = pos_begin;
		}
		s_ori.replace(pos_header,pos_end-pos_header,"");		//remove "-ZX_HEADER cl/abc.clT cl/def.clT" from s_ori
		return file_content;
	}
	return "";
}

NNCL_STATUS_E NnclGetKernelBySource(
                                NNCL_DEV_S *pClDev,
                                const char *kernelName, 
                                const char *kernSrcBuf, 
                                const char *buildOptions, 
                                NNCL_KERNEL_T *kernel)
{
    std::string key = kernelName;
    key.append(kernSrcBuf);
    std::string kernel_src_buf;
    std::string kernel_build_opt(buildOptions);

    if (buildOptions)
    {
        kernel_src_buf.append(processZxHeader(kernel_build_opt));
        key.append(buildOptions);
    }
    kernel_src_buf.append(kernSrcBuf);

    std::lock_guard<std::mutex> lock(pClDev->kernelLock);

    NNCL_STATUS_E clErr = NNCL_STATUS_SUCCESS;
    KERNEL_MAP &clKernelMap = pClDev->clKernelMap[pClDev->deviceIndex];
    auto &kernelSet = pClDev->kernelSet;

    auto iter = clKernelMap.find(key);

    if(iter != clKernelMap.end())
    {
        *kernel = iter->second;

        // add the kernel to local Set
        auto it = kernelSet.insert(*iter);
        if (it.second) // insert success ?
        {
            clErr  = nnclKernelRetain(*kernel);
            CL_ERR_EXIT2("nnclKernelCreate", kernelName);
        }
    }
    else
    {
        clErr  = nnclKernelCreate(kernel, kernelName, kernelName, kernel_build_opt.c_str(), kernel_src_buf.c_str()); //nnclKernelCreate api will implicate retain to 1.

        // add the kernel to global map
        clKernelMap.insert(make_pair(key, *kernel));
        // add the kernel to local Set
        kernelSet.insert(make_pair(key, *kernel));
    }

EXIT:
    
    return clErr;
}







TEST_P(Basic, TdataTest)
{
    int ret = ZXNN_STATUS_SUCCESS;
    float *p = (float *)malloc(2*3*5*5*sizeof(float));

    /* construct TData */
    TData ta(ZXNN_DATA_FLOAT);

    /* reshape, will malloc buffer, if have buffer already, will free and re-malloc */
    ta.Reshape(2,3,5,5);

    /* generate seq data, param is "begin" + "step" */
    ta.GenRandData(-2.5,2.5);
    ta.Show("ta(after GenRandData)");

    /* write TData content to buffer we specific */
    ta.CopyTo(p);
    ta.Store("./abc.txt");

    /* construct another TData */
    TData tb(2,3,5,5,ZXNN_DATA_FLOAT);
    tb.GenSeqData(0, 1.0);
    tb.Show("tb(GenSeqData)");

    /* read buffer to TData, will read "total_count_*sizeof(type)" bytes */
    tb.CopyFrom(p);
    tb.Show("tb(read from buf)");

    /* compare two TData */
    TData::SetTolerance(0.5);
    if(ta == tb) {
        std::cout << "ta==tb" << std::endl;
    } else {
        std::cout << "ta!=tb" << std::endl;
    }

    /* copy constructor and operator= */
    /*TData td = ta; // call copy constructor ?
    td.Show("TData td = ta");
    td = tb; //call operator= ?
    td.Show("td = tb");*/

   if(p)
        free(p);

    CONV_PARAM ConvParam;
    //memset(&ConvParam,0,sizeof(ConvParam)); //memset will destroy "this" pointer !!

    TestParamBase *pBase = &ConvParam;
    pBase->Show();

    ConvParam.n = 2;
    ConvParam.c = 2;
    ConvParam.h = 3;
    ConvParam.w = 3;
    ConvParam.pad_h = 1;
    ConvParam.pad_w = 1;
    ConvParam.stride_h = 1;
    ConvParam.stride_w = 1;
    ConvParam.dilation_h = 1;
    ConvParam.dilation_w = 1;
    ConvParam.wt_k = 1;
    ConvParam.wt_h = 3;
    ConvParam.wt_w = 3;
    ConvParam.groupCount = 1;
    ConvParam.alpha = 1;
    ConvParam.beta = 1.0;
    ConvParam.test_v_int.push_back(1);
    ConvParam.test_v_int.push_back(2);
    ConvParam.test_v_int.push_back(3);
    ConvParam.test_v_int.push_back(4);
    ConvParam.test_v_float.push_back(3.1);
    ConvParam.test_v_float.push_back(3.14);
    ConvParam.test_v_float.push_back(3.141);
    ConvParam.test_v_float.push_back(3.1415);
    ConvParam.test_v_float.push_back(3.14159);
    ConvParam.test_v_float.push_back(3.141592);
    ConvParam.test_v_float.push_back(3.1415926);

    pBase->Show();
    pBase->Store("./ddd.txt");
    pBase->Load("./ddd.txt");
    pBase->Show();


    //InitLogger("./info.log",LOG_FILTER_INFO|LOG_FILTER_ERROR);
    InitLogger("",LOG_FILTER_INFO|LOG_FILTER_ERROR);
    LOG(INFO) << "this is a test INFO0 log.";
    LOG(WARNING) << "this is a test WARNING0 log.";
    LOG(WARNING) << "this is a test WARNING1 log.";
    LOG(INFO) << "this is a test INFO1 log.";
    LOG(INFO) << "this is a test INFO2 log.";
    LOG(ERROR) << "this is a test ERROR0 log.";
    LOG(WARNING) << "this is a test WARNING2 log.";
    LOG(ERROR) << "this is a test ERROR1 log.";
    ResetLogger();

    NetParamParser parser;
    parser.ParseNet("../test/test_data/yolov2.net", "conv", 25, &ConvParam);
    pBase->Show();
}







int NetParamParser::ParseRawString(std::vector<std::string> inSet, int index, void *p)
{
    std::map<std::string, std::function<int(std::vector<std::string>,void *)> > SupportParser = {
        {"conv",     std::bind(&NetParamParser::LayerConvParamParser,this,std::placeholders::_1,std::placeholders::_2)},
        {"pool",     std::bind(&NetParamParser::LayerPoolingParamParser,this,std::placeholders::_1,std::placeholders::_2)}
    };
    std::string line;
    int curIndex = 0;

    bool pending = false;
    std::string layerName;
    std::string completeParam;
    for(int i = 0; i < inSet.size(); i++)
    {
        line = inSet[i];
        //line.strim
        line.erase(0, line.find_first_not_of(" "));
        line.erase(line.find_last_not_of(" ") + 1);

        //remove comments
        std::size_t pos_comment = line.find("//");
        if(pos_comment != line.npos)
        {
            line = line.substr(0, pos_comment);
            if(line.size() <= 0)
                continue;
        }

        std::size_t pos_left_start = line.find("[");
        std::size_t pos_right_end = line.find("]");
        if(pending)
        {
            if(pos_left_start != line.npos)
            {
                std::cout << "error: find [ in pending state !" <<std::endl;
                return -1;
            }
            if(pos_right_end != line.npos)
            {
                completeParam.append(line.substr(0, pos_right_end));
                pending = false;
            }
            else
            {
                completeParam.append(line).append("\n");
                continue;
            }
        }
        else //pending is false
        {
            if(pos_left_start != line.npos)
            {
                layerName = line.substr(0, pos_left_start);
                layerName.erase(0, layerName.find_first_not_of(" "));  //strim
                layerName.erase(layerName.find_last_not_of(" ") + 1);

                if(pos_right_end != line.npos)
                {
                    completeParam = line.substr(pos_left_start + 1, pos_right_end - pos_left_start - 1);//remove [ and ]
                }
                else
                {
                    completeParam.append(line.substr(pos_left_start + 1)).append("\n");
                    pending = true;
                    continue;
                }
            }
            else
            {
                continue;
            }
        }

        //pending is false when goto here.
        std::string strParams = completeParam;
        completeParam.clear();
        std::map<std::string, std::function<int(std::vector<std::string>,void *)> >::iterator iter = SupportParser.find(layerName);
        if(iter != SupportParser.end())
        {
            if(curIndex++ < index)
            {
                continue;
            }
            std::stringstream in(strParams);
            std::vector<std::string> vecParams;
            std::string param;
            while(in >> param)
            {
                vecParams.push_back(param);
            }
            if(vecParams.size() > 0 && (iter->second)(vecParams, p) != 0)
            {
                std::cout << "parse "<<layerName<<" layer encounter error. ignore."<<std::endl;
            }
            break;
        }
        else
        {
            std::cout << "layer("<<layerName<<") unknown." << std::endl;
        }
    }
    if(pending)
    {
        std::cout << "cannot find ] ?" <<std::endl;
    }
    return 0;
}



TEST_P(Basic, case1)
{
    int ret = ZXNN_STATUS_SUCCESS;
    ZXNN_CONV_FWD_ALGO_E supportAlgos[] = {ZXNN_CONV_FWD_ALGO_GEMM, ZXNN_CONV_FWD_ALGO_DIRECT};
    CONV_PARAM ConvParam;
    std::vector<std::string> testSet = {
        //n c h w pad_h pad_w stride_h stride_w dilation_h dilation_w wt_k wt_h wt_w groupCount
        "conv [ 2 2    3   3 1 1 1 1 1 1  1 3 3 1]",
        "conv [ 1 32 112 112 0 0 1 1 1 1 32 3 3 32]",
        "conv [ 1 3  416 416 1 1 1 1 1 1 32 3 3 1]",
    };

    TestMgr *p = TestMgr::getInstance();

    /* register and active */
#ifdef USE_CUDNN
    p->RegisterDevTest(TEST_DEVICE_CUDNN, CudnnConvFwdTest, &ConvParam);
#endif
    p->RegisterDevTest(TEST_DEVICE_CL_GPU_REF, RefConvFwdTest, &ConvParam);
    //p->RegisterDevTest(TEST_DEVICE_CL_GPU_REF,"non-fuse", RefConvFwdTest, &ConvParam);
    p->RegisterDevTest(TEST_DEVICE_CL_E3K_ASM, AsmConvFwdTest, &ConvParam);
    p->RegisterDevTest(TEST_DEVICE_CL_E3K_SRC, SrcConvFwdTest, &ConvParam);

    /* set framework param */
    p->AddTestDataType(ZXNN_DATA_FLOAT);	//global test data types
    p->AddTestDataType(ZXNN_DATA_HALF);

    p->SetCompareTolerance(0.5);
    std::vector<int> xShape(4);
    std::vector<int> wShape(4);

    NetParamParser parser;
    /* run */
    for(int i = 0; i < testSet.size(); i++)
    {
        for(int j = 0; j < sizeof(supportAlgos)/sizeof(supportAlgos[0]); j++)
        {
            if(parser.ParseRawString(testSet, i, &ConvParam)== 0)
            {
                ConvParam.convAlgo = (int)supportAlgos[j];
                //ConvParam.Show();

                p->ClearInput();
                xShape[0] = ConvParam.n;
                xShape[1] = ConvParam.c;
                xShape[2] = ConvParam.h;
                xShape[3] = ConvParam.w;
                p->AddRandomInput(xShape, -1.0, 1.0);
                wShape[0] = ConvParam.wt_k;
                wShape[1] = ConvParam.c / ConvParam.groupCount;
                wShape[2] = ConvParam.wt_h;
                wShape[3] = ConvParam.wt_w;
                p->AddRandomInput(wShape, -1.0, 1.0);
                p->RunTest();
            }
        }
    }
}

